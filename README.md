# POSIX-Threading
I recently ran into a problem with locking pthreads in C when they are calling the same function, and was curious as to why mutexes were not activating. After learning that it was a computer architecture issue with how the OS efficiently runs its cores, I decided to explore other ways to lock a thread function when using smaller instructions (mutexes would work when there was a lot to process, but smaller cases would ignore than mutex). This is one workaround which uses pthread ids and the pthread_self() API to manage thread executions when the code is too small for mutexes to take effect.

A note about compiling - this program compiles well on a Linux machine. This particular program was compiled on std=c11 from a Fedora machine. When trying to compile the program on Cygwin, there were compilation issues surrounding pthread_id data types printing as long ints, which is not an issue when compiling in a Linux environment. If running this program, please do so from a Linux machine "gcc -Wall -o threads threads.c -lpthread".

What the program is doing:
This program has two threads which call the same function. What we are trying to do is to make a producer thread update a struct before having the consumer thread print it out. Due to race conditions, we want to make sure that the producer does this first. What you will see in the code is that once we call the pthread_create() function, the API call updates the thread id, from there, we store the ID in the struct so the thread functions have access to it. In doing so, we know to only allow the thread to run past a certain point if it is the producer or consumer.

